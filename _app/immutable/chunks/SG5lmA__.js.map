{"version":3,"file":"SG5lmA__.js","sources":["../../../../../../src/lib/nostr/channels.ts"],"sourcesContent":["/**\n * Channel Service - Nostr channel operations using NDK\n * Implements NIP-28 (Public Chat) event kinds\n */\nimport { NDKEvent, type NDKFilter } from '@nostr-dev-kit/ndk';\nimport { ndk, connectNDK, hasSigner } from './ndk';\nimport { browser } from '$app/environment';\n\n// NIP-28 Event Kinds for Public Chat\nexport const CHANNEL_KINDS = {\n\tCREATE: 40,      // Channel creation\n\tMETADATA: 41,    // Channel metadata\n\tMESSAGE: 42,     // Channel message\n\tHIDE_MESSAGE: 43, // Hide message\n\tMUTE_USER: 44,   // Mute user in channel\n} as const;\n\nexport interface ChannelMetadata {\n\tname: string;\n\tabout?: string;\n\tpicture?: string;\n\trelays?: string[];\n}\n\nexport interface ChannelCreateOptions {\n\tname: string;\n\tdescription?: string;\n\tvisibility?: 'public' | 'cohort' | 'private';\n\tcohorts?: string[];\n\tencrypted?: boolean;\n}\n\nexport interface CreatedChannel {\n\tid: string;\n\tname: string;\n\tdescription?: string;\n\tvisibility: 'public' | 'cohort' | 'private';\n\tcohorts: string[];\n\tencrypted: boolean;\n\tcreatedAt: number;\n\tcreatorPubkey: string;\n}\n\n/**\n * Create a new channel (NIP-28 kind 40)\n */\nexport async function createChannel(options: ChannelCreateOptions): Promise<CreatedChannel> {\n\tif (!browser) {\n\t\tthrow new Error('Channel creation requires browser environment');\n\t}\n\n\tif (!hasSigner()) {\n\t\tthrow new Error('No signer configured. Please login first.');\n\t}\n\n\t// Ensure connected\n\tawait connectNDK();\n\n\t// Build channel metadata\n\tconst metadata: ChannelMetadata = {\n\t\tname: options.name,\n\t\tabout: options.description,\n\t};\n\n\t// Create the event\n\tconst event = new NDKEvent(ndk);\n\tevent.kind = CHANNEL_KINDS.CREATE;\n\tevent.content = JSON.stringify(metadata);\n\n\t// Add custom tags for visibility/cohorts\n\tif (options.visibility && options.visibility !== 'public') {\n\t\tevent.tags.push(['visibility', options.visibility]);\n\t}\n\n\tif (options.cohorts && options.cohorts.length > 0) {\n\t\tevent.tags.push(['cohort', options.cohorts.join(',')]);\n\t}\n\n\tif (options.encrypted) {\n\t\tevent.tags.push(['encrypted', 'true']);\n\t}\n\n\t// Sign and publish\n\tawait event.sign();\n\tawait event.publish();\n\n\tconsole.log('Channel created:', event.id);\n\n\treturn {\n\t\tid: event.id,\n\t\tname: options.name,\n\t\tdescription: options.description,\n\t\tvisibility: options.visibility || 'public',\n\t\tcohorts: options.cohorts || [],\n\t\tencrypted: options.encrypted || false,\n\t\tcreatedAt: event.created_at || Math.floor(Date.now() / 1000),\n\t\tcreatorPubkey: event.pubkey,\n\t};\n}\n\n/**\n * Update channel metadata (NIP-28 kind 41)\n */\nexport async function updateChannelMetadata(\n\tchannelId: string,\n\tmetadata: Partial<ChannelMetadata>\n): Promise<void> {\n\tif (!browser) {\n\t\tthrow new Error('Channel operations require browser environment');\n\t}\n\n\tif (!hasSigner()) {\n\t\tthrow new Error('No signer configured. Please login first.');\n\t}\n\n\tawait connectNDK();\n\n\tconst event = new NDKEvent(ndk);\n\tevent.kind = CHANNEL_KINDS.METADATA;\n\tevent.content = JSON.stringify(metadata);\n\tevent.tags.push(['e', channelId, '', 'root']);\n\n\tawait event.sign();\n\tawait event.publish();\n\n\tconsole.log('Channel metadata updated:', channelId);\n}\n\n/**\n * Send a message to a channel (NIP-28 kind 42)\n */\nexport async function sendChannelMessage(\n\tchannelId: string,\n\tcontent: string,\n\treplyTo?: string\n): Promise<string> {\n\tif (!browser) {\n\t\tthrow new Error('Channel operations require browser environment');\n\t}\n\n\tif (!hasSigner()) {\n\t\tthrow new Error('No signer configured. Please login first.');\n\t}\n\n\tawait connectNDK();\n\n\tconst event = new NDKEvent(ndk);\n\tevent.kind = CHANNEL_KINDS.MESSAGE;\n\tevent.content = content;\n\tevent.tags.push(['e', channelId, '', 'root']);\n\n\tif (replyTo) {\n\t\tevent.tags.push(['e', replyTo, '', 'reply']);\n\t}\n\n\tawait event.sign();\n\tawait event.publish();\n\n\tconsole.log('Message sent to channel:', channelId);\n\treturn event.id;\n}\n\n/**\n * Fetch channels from relays\n */\nexport async function fetchChannels(limit = 100): Promise<CreatedChannel[]> {\n\tif (!browser) {\n\t\treturn [];\n\t}\n\n\tawait connectNDK();\n\n\tconst filter: NDKFilter = {\n\t\tkinds: [CHANNEL_KINDS.CREATE],\n\t\tlimit,\n\t};\n\n\tconst events = await ndk.fetchEvents(filter);\n\tconst channels: CreatedChannel[] = [];\n\n\tfor (const event of events) {\n\t\ttry {\n\t\t\tconst metadata = JSON.parse(event.content) as ChannelMetadata;\n\t\t\tconst visibilityTag = event.tags.find(t => t[0] === 'visibility');\n\t\t\tconst cohortTag = event.tags.find(t => t[0] === 'cohort');\n\t\t\tconst encryptedTag = event.tags.find(t => t[0] === 'encrypted');\n\n\t\t\tchannels.push({\n\t\t\t\tid: event.id,\n\t\t\t\tname: metadata.name || 'Unnamed Channel',\n\t\t\t\tdescription: metadata.about,\n\t\t\t\tvisibility: (visibilityTag?.[1] as any) || 'public',\n\t\t\t\tcohorts: cohortTag?.[1]?.split(',').filter(Boolean) || [],\n\t\t\t\tencrypted: encryptedTag?.[1] === 'true',\n\t\t\t\tcreatedAt: event.created_at || 0,\n\t\t\t\tcreatorPubkey: event.pubkey,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to parse channel event:', e);\n\t\t}\n\t}\n\n\t// Sort by creation time (newest first)\n\tchannels.sort((a, b) => b.createdAt - a.createdAt);\n\n\treturn channels;\n}\n\n/**\n * Fetch messages for a channel\n */\nexport async function fetchChannelMessages(\n\tchannelId: string,\n\tlimit = 50\n): Promise<Array<{\n\tid: string;\n\tcontent: string;\n\tpubkey: string;\n\tcreatedAt: number;\n\treplyTo?: string;\n}>> {\n\tif (!browser) {\n\t\treturn [];\n\t}\n\n\tawait connectNDK();\n\n\tconst filter: NDKFilter = {\n\t\tkinds: [CHANNEL_KINDS.MESSAGE],\n\t\t'#e': [channelId],\n\t\tlimit,\n\t};\n\n\tconst events = await ndk.fetchEvents(filter);\n\tconst messages: Array<{\n\t\tid: string;\n\t\tcontent: string;\n\t\tpubkey: string;\n\t\tcreatedAt: number;\n\t\treplyTo?: string;\n\t}> = [];\n\n\tfor (const event of events) {\n\t\tconst replyTag = event.tags.find(t => t[0] === 'e' && t[3] === 'reply');\n\n\t\tmessages.push({\n\t\t\tid: event.id,\n\t\t\tcontent: event.content,\n\t\t\tpubkey: event.pubkey,\n\t\t\tcreatedAt: event.created_at || 0,\n\t\t\treplyTo: replyTag?.[1],\n\t\t});\n\t}\n\n\t// Sort by creation time (oldest first for messages)\n\tmessages.sort((a, b) => a.createdAt - b.createdAt);\n\n\treturn messages;\n}\n\n/**\n * Subscribe to channel messages in real-time\n */\nexport function subscribeToChannel(\n\tchannelId: string,\n\tonMessage: (message: {\n\t\tid: string;\n\t\tcontent: string;\n\t\tpubkey: string;\n\t\tcreatedAt: number;\n\t\treplyTo?: string;\n\t}) => void\n): { unsubscribe: () => void } {\n\tif (!browser) {\n\t\treturn { unsubscribe: () => {} };\n\t}\n\n\tconst filter: NDKFilter = {\n\t\tkinds: [CHANNEL_KINDS.MESSAGE],\n\t\t'#e': [channelId],\n\t\tsince: Math.floor(Date.now() / 1000),\n\t};\n\n\tconst sub = ndk.subscribe(filter, { closeOnEose: false });\n\n\tsub.on('event', (event: NDKEvent) => {\n\t\tconst replyTag = event.tags.find(t => t[0] === 'e' && t[3] === 'reply');\n\n\t\tonMessage({\n\t\t\tid: event.id,\n\t\t\tcontent: event.content,\n\t\t\tpubkey: event.pubkey,\n\t\t\tcreatedAt: event.created_at || 0,\n\t\t\treplyTo: replyTag?.[1],\n\t\t});\n\t});\n\n\treturn {\n\t\tunsubscribe: () => {\n\t\t\tsub.stop();\n\t\t},\n\t};\n}\n"],"names":["CHANNEL_KINDS","createChannel","options","hasSigner","connectNDK","metadata","event","NDKEvent","ndk","fetchChannels","limit","filter","events","channels","visibilityTag","t","cohortTag","encryptedTag","e","b"],"mappings":"uDASO,MAAMA,EAAgB,CAC5B,OAAQ,EAKT,EA+BA,eAAsBC,EAAcC,EAAwD,CAK3F,GAAI,CAACC,IACJ,MAAM,IAAI,MAAM,2CAA2C,EAI5D,MAAMC,EAAA,EAGN,MAAMC,EAA4B,CACjC,KAAMH,EAAQ,KACd,MAAOA,EAAQ,WAAA,EAIVI,EAAQ,IAAIC,EAASC,CAAG,EAC9B,OAAAF,EAAM,KAAON,EAAc,OAC3BM,EAAM,QAAU,KAAK,UAAUD,CAAQ,EAGnCH,EAAQ,YAAcA,EAAQ,aAAe,UAChDI,EAAM,KAAK,KAAK,CAAC,aAAcJ,EAAQ,UAAU,CAAC,EAG/CA,EAAQ,SAAWA,EAAQ,QAAQ,OAAS,GAC/CI,EAAM,KAAK,KAAK,CAAC,SAAUJ,EAAQ,QAAQ,KAAK,GAAG,CAAC,CAAC,EAGlDA,EAAQ,WACXI,EAAM,KAAK,KAAK,CAAC,YAAa,MAAM,CAAC,EAItC,MAAMA,EAAM,KAAA,EACZ,MAAMA,EAAM,QAAA,EAEZ,QAAQ,IAAI,mBAAoBA,EAAM,EAAE,EAEjC,CACN,GAAIA,EAAM,GACV,KAAMJ,EAAQ,KACd,YAAaA,EAAQ,YACrB,WAAYA,EAAQ,YAAc,SAClC,QAASA,EAAQ,SAAW,CAAA,EAC5B,UAAWA,EAAQ,WAAa,GAChC,UAAWI,EAAM,YAAc,KAAK,MAAM,KAAK,IAAA,EAAQ,GAAI,EAC3D,cAAeA,EAAM,MAAA,CAEvB,CAmEA,eAAsBG,EAAcC,EAAQ,IAAgC,CAK3E,MAAMN,EAAA,EAEN,MAAMO,EAAoB,CACzB,MAAO,CAACX,EAAc,MAAM,EAC5B,MAAAU,CAAA,EAGKE,EAAS,MAAMJ,EAAI,YAAYG,CAAM,EACrCE,EAA6B,CAAA,EAEnC,UAAWP,KAASM,EACnB,GAAI,CACH,MAAMP,EAAW,KAAK,MAAMC,EAAM,OAAO,EACnCQ,EAAgBR,EAAM,KAAK,QAAUS,EAAE,CAAC,IAAM,YAAY,EAC1DC,EAAYV,EAAM,KAAK,QAAUS,EAAE,CAAC,IAAM,QAAQ,EAClDE,EAAeX,EAAM,KAAK,QAAUS,EAAE,CAAC,IAAM,WAAW,EAE9DF,EAAS,KAAK,CACb,GAAIP,EAAM,GACV,KAAMD,EAAS,MAAQ,kBACvB,YAAaA,EAAS,MACtB,WAAaS,IAAgB,CAAC,GAAa,SAC3C,QAASE,IAAY,CAAC,GAAG,MAAM,GAAG,EAAE,OAAO,OAAO,GAAK,CAAA,EACvD,UAAWC,IAAe,CAAC,IAAM,OACjC,UAAWX,EAAM,YAAc,EAC/B,cAAeA,EAAM,MAAA,CACrB,CACF,OAASY,EAAG,CACX,QAAQ,MAAM,iCAAkCA,CAAC,CAClD,CAID,OAAAL,EAAS,KAAK,CAAC,EAAGM,IAAMA,EAAE,UAAY,EAAE,SAAS,EAE1CN,CACR"}