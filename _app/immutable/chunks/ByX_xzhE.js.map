{"version":3,"file":"ByX_xzhE.js","sources":["../../../../../../src/lib/stores/channels.ts"],"sourcesContent":["import { writable, derived, get } from 'svelte/store';\nimport type NDK from '@nostr-dev-kit/ndk';\nimport type { NDKEvent, NDKFilter, NDKRelay } from '@nostr-dev-kit/ndk';\n\n// Channel interface as per SPARC specification\nexport interface Channel {\n  id: string;                                    // h tag value (group ID)\n  name: string;                                  // From kind 39000 metadata\n  description: string;\n  picture?: string;                              // Avatar URL\n  cohorts: ('business' | 'moomaa-tribe')[];\n  visibility: 'listed' | 'unlisted' | 'preview';\n  isEncrypted: boolean;                          // E2E vs transport only\n  memberCount: number;\n  createdAt: number;\n\n  // User-specific state\n  isMember: boolean;\n  hasRequestPending: boolean;\n}\n\n// Store state interface\nexport interface ChannelStore {\n  channels: Channel[];\n  loading: boolean;\n  error: string | null;\n  currentChannel: Channel | null;\n}\n\n// NIP-29 event kinds\nconst KIND_GROUP_METADATA = 39000;    // Group metadata event\nconst KIND_GROUP_MEMBERS = 39002;     // Group member list\nconst KIND_JOIN_REQUEST = 9021;       // Custom: user join requests\n\n// Initial state\nconst initialState: ChannelStore = {\n  channels: [],\n  loading: false,\n  error: null,\n  currentChannel: null,\n};\n\n// Create the writable store\nconst { subscribe, set, update } = writable<ChannelStore>(initialState);\n\n/**\n * Fetch all channels from relay with cohort filtering\n *\n * @param ndk - NDK instance connected to relay\n * @param userPubkey - Current user's public key\n * @param userCohorts - User's cohort tags (business, moomaa-tribe, or both)\n * @returns Promise<Channel[]>\n */\nexport async function fetchChannels(\n  ndk: NDK,\n  userPubkey: string,\n  userCohorts: ('business' | 'moomaa-tribe')[]\n): Promise<Channel[]> {\n  update(state => ({ ...state, loading: true, error: null }));\n\n  try {\n    // 1. Fetch all group metadata events (kind 39000)\n    const metadataFilter: NDKFilter = {\n      kinds: [KIND_GROUP_METADATA],\n    };\n\n    const metadataEvents = await ndk.fetchEvents(metadataFilter);\n    const metadataArray = Array.from(metadataEvents);\n\n    // 2. Fetch all member lists (kind 39002)\n    const memberFilter: NDKFilter = {\n      kinds: [KIND_GROUP_MEMBERS],\n    };\n\n    const memberEvents = await ndk.fetchEvents(memberFilter);\n    const memberArray = Array.from(memberEvents);\n\n    // 3. Fetch user's pending join requests (kind 9021)\n    const requestFilter: NDKFilter = {\n      kinds: [KIND_JOIN_REQUEST],\n      authors: [userPubkey],\n    };\n\n    const pendingRequests = await ndk.fetchEvents(requestFilter);\n    const requestArray = Array.from(pendingRequests);\n\n    // 4. Build Channel objects\n    const channels: Channel[] = [];\n\n    for (const metaEvent of metadataArray) {\n      const channel = buildChannelFromEvents(\n        metaEvent,\n        memberArray,\n        requestArray,\n        userPubkey,\n        userCohorts\n      );\n\n      if (channel) {\n        channels.push(channel);\n      }\n    }\n\n    // 5. Update store with fetched channels\n    update(state => ({\n      ...state,\n      channels,\n      loading: false,\n      error: null,\n    }));\n\n    return channels;\n\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Failed to fetch channels';\n\n    update(state => ({\n      ...state,\n      loading: false,\n      error: errorMessage,\n    }));\n\n    throw error;\n  }\n}\n\n/**\n * Build a Channel object from relay events with cohort filtering\n *\n * @param metaEvent - kind 39000 group metadata event\n * @param memberEvents - Array of kind 39002 member list events\n * @param requestEvents - Array of kind 9021 join request events\n * @param userPubkey - Current user's public key\n * @param userCohorts - User's cohort memberships\n * @returns Channel | null (null if user shouldn't see this channel)\n */\nfunction buildChannelFromEvents(\n  metaEvent: NDKEvent,\n  memberEvents: NDKEvent[],\n  requestEvents: NDKEvent[],\n  userPubkey: string,\n  userCohorts: ('business' | 'moomaa-tribe')[]\n): Channel | null {\n  // Extract group ID from 'd' tag\n  const groupId = metaEvent.tags.find(t => t[0] === 'd')?.[1];\n  if (!groupId) return null;\n\n  // Extract cohort tags\n  const channelCohorts = metaEvent.tags\n    .filter(t => t[0] === 'cohort')\n    .map(t => t[1] as 'business' | 'moomaa-tribe');\n\n  // Apply cohort filtering logic as per SPARC:\n  // - business cohort sees business channels\n  // - moomaa-tribe sees moomaa channels\n  // - dual-cohort users see all (unified view)\n  const hasMatchingCohort = channelCohorts.some(channelCohort =>\n    userCohorts.includes(channelCohort)\n  );\n\n  // If no cohort match and user isn't dual-cohort, filter out\n  if (!hasMatchingCohort && channelCohorts.length > 0) {\n    return null;\n  }\n\n  // Parse metadata content\n  let metadata: {\n    name?: string;\n    about?: string;\n    picture?: string;\n  } = {};\n\n  try {\n    metadata = JSON.parse(metaEvent.content);\n  } catch {\n    // If content isn't valid JSON, use defaults\n    metadata = {};\n  }\n\n  // Find matching member list event\n  const memberEvent = memberEvents.find(m => {\n    const memberGroupId = m.tags.find(t => t[0] === 'd')?.[1];\n    return memberGroupId === groupId;\n  });\n\n  // Extract member pubkeys\n  const memberPubkeys = memberEvent?.tags\n    .filter(t => t[0] === 'p')\n    .map(t => t[1]) || [];\n\n  const memberCount = memberPubkeys.length;\n  const isMember = memberPubkeys.includes(userPubkey);\n\n  // Check if user has pending request for this channel\n  const hasRequestPending = requestEvents.some(r => {\n    const requestChannelId = r.tags.find(t => t[0] === 'h')?.[1];\n    return requestChannelId === groupId;\n  });\n\n  // Extract visibility setting\n  const visibilityTag = metaEvent.tags.find(t => t[0] === 'visibility')?.[1];\n  const visibility = (visibilityTag as 'listed' | 'unlisted' | 'preview') || 'listed';\n\n  // Check if channel is encrypted (E2E)\n  const isEncrypted = metaEvent.tags.some(t => t[0] === 'encrypted');\n\n  // Handle visibility filtering for non-members\n  if (!isMember && visibility === 'unlisted') {\n    return null;  // Unlisted channels hidden from non-members\n  }\n\n  return {\n    id: groupId,\n    name: metadata.name || 'Unnamed Channel',\n    description: metadata.about || '',\n    picture: metadata.picture,\n    cohorts: channelCohorts,\n    visibility,\n    isEncrypted,\n    memberCount,\n    createdAt: metaEvent.created_at || 0,\n    isMember,\n    hasRequestPending,\n  };\n}\n\n/**\n * Set the current active channel\n */\nexport function setCurrentChannel(channel: Channel | null): void {\n  update(state => ({\n    ...state,\n    currentChannel: channel,\n  }));\n}\n\n/**\n * Get current channel (synchronous)\n */\nexport function getCurrentChannel(): Channel | null {\n  return get(channelStore).currentChannel;\n}\n\n// Lazy-initialized derived stores to avoid circular initialization\nlet _memberChannels: ReturnType<typeof derived<typeof channelStore, Channel[]>> | null = null;\nlet _availableChannels: ReturnType<typeof derived<typeof channelStore, Channel[]>> | null = null;\n\n/**\n * Filter channels by membership status (lazy initialization)\n */\nexport function getMemberChannels() {\n  if (!_memberChannels) {\n    _memberChannels = derived(channelStore, $store => $store.channels.filter(c => c.isMember));\n  }\n  return _memberChannels;\n}\n\n/**\n * Filter channels by non-membership (lazy initialization)\n */\nexport function getAvailableChannels() {\n  if (!_availableChannels) {\n    _availableChannels = derived(channelStore, $store => $store.channels.filter(c => !c.isMember && c.visibility !== 'unlisted'));\n  }\n  return _availableChannels;\n}\n\n// Backwards-compatible exports\nexport const memberChannels = {\n  subscribe: (fn: (value: Channel[]) => void) => getMemberChannels().subscribe(fn)\n};\n\nexport const availableChannels = {\n  subscribe: (fn: (value: Channel[]) => void) => getAvailableChannels().subscribe(fn)\n};\n\n/**\n * Filter channels by cohort\n */\nexport function getChannelsByCohort(cohort: 'business' | 'moomaa-tribe'): Channel[] {\n  const state = get(channelStore);\n  return state.channels.filter(c => c.cohorts.includes(cohort));\n}\n\n/**\n * Clear all channels (e.g., on logout)\n */\nexport function clearChannels(): void {\n  set(initialState);\n}\n\n/**\n * Update a single channel in the store\n */\nexport function updateChannel(channelId: string, updates: Partial<Channel>): void {\n  update(state => ({\n    ...state,\n    channels: state.channels.map(c =>\n      c.id === channelId ? { ...c, ...updates } : c\n    ),\n  }));\n}\n\n/**\n * Remove a channel from the store\n */\nexport function removeChannel(channelId: string): void {\n  update(state => ({\n    ...state,\n    channels: state.channels.filter(c => c.id !== channelId),\n    currentChannel: state.currentChannel?.id === channelId ? null : state.currentChannel,\n  }));\n}\n\n// Export the store\nexport const channelStore = {\n  subscribe,\n  set,\n  update,\n  fetchChannels,\n  setCurrentChannel,\n  getCurrentChannel,\n  getChannelsByCohort,\n  clearChannels,\n  updateChannel,\n  removeChannel,\n};\n"],"names":["KIND_GROUP_METADATA","KIND_GROUP_MEMBERS","KIND_JOIN_REQUEST","initialState","subscribe","set","update","writable","fetchChannels","ndk","userPubkey","userCohorts","state","metadataFilter","metadataEvents","metadataArray","memberFilter","memberEvents","memberArray","requestFilter","pendingRequests","requestArray","channels","metaEvent","channel","buildChannelFromEvents","error","errorMessage","requestEvents","groupId","t","channelCohorts","channelCohort","metadata","memberPubkeys","m","memberCount","isMember","hasRequestPending","r","visibility","isEncrypted","setCurrentChannel","getCurrentChannel","get","channelStore","getChannelsByCohort","cohort","c","clearChannels","updateChannel","channelId","updates","removeChannel"],"mappings":"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"}