import{w as q}from"./D2J3qzGV.js";import{q as y}from"./D9KvLAFu.js";const M=39e3,w=39002,R=9021,E={channels:[],loading:!1,error:null,currentChannel:null},{subscribe:F,set:v,update:c}=q(E);async function N(n,t,s){c(r=>({...r,loading:!0,error:null}));try{const r={kinds:[M]},l=await n.fetchEvents(r),a=Array.from(l),u={kinds:[w]},C=await n.fetchEvents(u),o=Array.from(C),p={kinds:[R],authors:[t]},d=await n.fetchEvents(p),m=Array.from(d),i=[];for(const h of a){const f=S(h,o,m,t,s);f&&i.push(f)}return c(h=>({...h,channels:i,loading:!1,error:null})),i}catch(r){const l=r instanceof Error?r.message:"Failed to fetch channels";throw c(a=>({...a,loading:!1,error:l})),r}}function S(n,t,s,r,l){const a=n.tags.find(e=>e[0]==="d")?.[1];if(!a)return null;const u=n.tags.filter(e=>e[0]==="cohort").map(e=>e[1]);if(!u.some(e=>l.includes(e))&&u.length>0)return null;let o={};try{o=JSON.parse(n.content)}catch{o={}}const d=t.find(e=>e.tags.find(g=>g[0]==="d")?.[1]===a)?.tags.filter(e=>e[0]==="p").map(e=>e[1])||[],m=d.length,i=d.includes(r),h=s.some(e=>e.tags.find(g=>g[0]==="h")?.[1]===a),b=n.tags.find(e=>e[0]==="visibility")?.[1]||"listed",_=n.tags.some(e=>e[0]==="encrypted");return!i&&b==="unlisted"?null:{id:a,name:o.name||"Unnamed Channel",description:o.about||"",picture:o.picture,cohorts:u,visibility:b,isEncrypted:_,memberCount:m,createdAt:n.created_at||0,isMember:i,hasRequestPending:h}}function T(n){c(t=>({...t,currentChannel:n}))}function D(){return y(A).currentChannel}function G(n){return y(A).channels.filter(s=>s.cohorts.includes(n))}function O(){v(E)}function U(n,t){c(s=>({...s,channels:s.channels.map(r=>r.id===n?{...r,...t}:r)}))}function K(n){c(t=>({...t,channels:t.channels.filter(s=>s.id!==n),currentChannel:t.currentChannel?.id===n?null:t.currentChannel}))}const A={subscribe:F,set:v,update:c,fetchChannels:N,setCurrentChannel:T,getCurrentChannel:D,getChannelsByCohort:G,clearChannels:O,updateChannel:U,removeChannel:K};export{A as c};
//# sourceMappingURL=ByX_xzhE.js.map
