{"version":3,"sources":["../../../src/service-worker.ts"],"names":["manifest","CACHE_VERSION","STATIC_CACHE","DYNAMIC_CACHE","PROFILE_CACHE","STATIC_ASSETS","entry","QUEUE_DB_NAME","QUEUE_STORE_NAME","QUEUE_DB_VERSION","initQueueDB","resolve","reject","request","event","db","queueMessage","message","getQueuedMessages","dequeueMessage","id","clearQueue","cacheNames","name","getCachingStrategy","url","pathname","cacheFirst","cacheName","cached","response","error","networkFirst","staleWhileRevalidate","fetchPromise","c","strategy","syncEvent","messages","r","client","type","payload","data","clients"],"mappings":"AAUA,MAAM,EAAW,+yEAAK,cAEhB,EAAgB,KAChB,EAAe,0BAA0B,CAAa,GACtD,EAAgB,2BAA2B,CAAa,GACxD,EAAgB,4BAA4B,CAAa,GAGzD,EAAgB,GAAU,OAAS,EACrC,EAAS,IAAK,GAA2B,EAAM,GAAG,EAClD,CACE,IACA,cACA,iBACA,cACF,EAEE,EAAgB,wBAChB,EAAmB,oBACnB,EAAmB,EAsBzB,eAAe,GAAoC,CACjD,OAAO,IAAI,QAAQ,CAAC,EAAS,IAAW,CACtC,MAAM,EAAU,UAAU,KAAK,EAAe,CAAgB,EAE9D,EAAQ,QAAU,IAAM,EAAO,EAAQ,KAAK,EAC5C,EAAQ,UAAY,IAAM,EAAQ,EAAQ,MAAM,EAEhD,EAAQ,gBAAmB,GAAU,CACnC,MAAM,EAAM,EAAM,OAA4B,OAEzC,EAAG,iBAAiB,SAAS,CAAgB,GAClC,EAAG,kBAAkB,EAAkB,CAAE,QAAS,KAAM,EAChE,YAAY,YAAa,YAAa,CAAE,OAAQ,GAAO,CAEjE,CACF,CAAC,CACH,CAKA,eAAe,EAAa,EAAuC,CACjE,MAAM,EAAK,MAAM,EAAA,EAEjB,OAAO,IAAI,QAAQ,CAAC,EAAS,IAAW,CAGtC,MAAM,EAFc,EAAG,YAAY,CAAC,CAAgB,EAAG,WAAW,EACxC,YAAY,CAAgB,EAChC,IAAI,CAAO,EAEjC,EAAQ,UAAY,IAAM,EAAA,EAC1B,EAAQ,QAAU,IAAM,EAAO,EAAQ,KAAK,CAC9C,CAAC,CACH,CAKA,eAAe,GAA8C,CAC3D,MAAM,EAAK,MAAM,EAAA,EAEjB,OAAO,IAAI,QAAQ,CAAC,EAAS,IAAW,CAGtC,MAAM,EAFc,EAAG,YAAY,CAAC,CAAgB,EAAG,UAAU,EACvC,YAAY,CAAgB,EAChC,OAAA,EAEtB,EAAQ,UAAY,IAAM,EAAQ,EAAQ,MAAM,EAChD,EAAQ,QAAU,IAAM,EAAO,EAAQ,KAAK,CAC9C,CAAC,CACH,CAKA,eAAe,EAAe,EAA2B,CACvD,MAAM,EAAK,MAAM,EAAA,EAEjB,OAAO,IAAI,QAAQ,CAAC,EAAS,IAAW,CAGtC,MAAM,EAFc,EAAG,YAAY,CAAC,CAAgB,EAAG,WAAW,EACxC,YAAY,CAAgB,EAChC,OAAO,CAAE,EAE/B,EAAQ,UAAY,IAAM,EAAA,EAC1B,EAAQ,QAAU,IAAM,EAAO,EAAQ,KAAK,CAC9C,CAAC,CACH,CAKA,eAAe,GAA4B,CACzC,MAAM,EAAK,MAAM,EAAA,EAEjB,OAAO,IAAI,QAAQ,CAAC,EAAS,IAAW,CAGtC,MAAM,EAFc,EAAG,YAAY,CAAC,CAAgB,EAAG,WAAW,EACxC,YAAY,CAAgB,EAChC,MAAA,EAEtB,EAAQ,UAAY,IAAM,EAAA,EAC1B,EAAQ,QAAU,IAAM,EAAO,EAAQ,KAAK,CAC9C,CAAC,CACH,CAKA,KAAK,iBAAiB,UAAY,GAAU,CAC1C,QAAQ,IAAI,mCAAmC,EAE/C,EAAM,WACH,SAAY,CAEX,MADc,MAAM,OAAO,KAAK,CAAY,GAChC,OAAO,CAAa,EAChC,MAAM,KAAK,YAAA,CACb,GAAA,CAAG,CAEP,CAAC,EAKD,KAAK,iBAAiB,WAAa,GAAU,CAC3C,QAAQ,IAAI,mCAAmC,EAE/C,EAAM,WACH,SAAY,CACX,MAAM,EAAa,MAAM,OAAO,KAAA,EAChC,MAAM,QAAQ,IACZ,EACG,OAAO,GACN,EAAK,WAAW,kBAAkB,GAClC,CAAC,EAAK,SAAS,CAAa,CAAA,EAE7B,IAAI,GAAQ,OAAO,OAAO,CAAI,CAAC,CAAA,EAEpC,MAAM,KAAK,QAAQ,MAAA,CACrB,GAAA,CAAG,CAEP,CAAC,EAKD,SAAS,EAAmB,EAAuF,CACjH,MAAM,EAAW,EAAI,SAGrB,OAAI,EAAI,WAAa,QAAU,EAAI,WAAa,MACvC,eAKP,EAAS,SAAS,KAAK,GACvB,EAAS,SAAS,MAAM,GACxB,EAAS,SAAS,OAAO,GACzB,EAAS,SAAS,MAAM,GACxB,EAAS,SAAS,MAAM,GACxB,EAAS,SAAS,MAAM,GACxB,EAAS,SAAS,MAAM,GACxB,EAAS,SAAS,QAAQ,GAC1B,EAAS,SAAS,OAAO,GACzB,EAAS,SAAS,MAAM,EAEjB,cAKP,EAAS,SAAS,SAAS,GAC3B,EAAS,SAAS,UAAU,GAC5B,EAAS,SAAS,WAAW,EAEtB,yBAIF,eACT,CAKA,eAAe,EAAW,EAAkB,EAAsC,CAChF,MAAM,EAAS,MAAM,OAAO,MAAM,CAAO,EAEzC,GAAI,EACF,OAAO,EAGT,GAAI,CACF,MAAM,EAAW,MAAM,MAAM,CAAO,EAEpC,OAAI,EAAS,KACG,MAAM,OAAO,KAAK,CAAS,GACnC,IAAI,EAAS,EAAS,MAAA,CAAO,EAG9B,CACT,OAAS,EAAO,CACd,eAAQ,MAAM,iCAAkC,CAAK,EAC9C,IAAI,SAAS,UAAW,CAAE,OAAQ,IAAK,CAChD,CACF,CAKA,eAAe,EAAa,EAAkB,EAAsC,CAClF,GAAI,CACF,MAAM,EAAW,MAAM,MAAM,CAAO,EAEpC,OAAI,EAAS,KACG,MAAM,OAAO,KAAK,CAAS,GACnC,IAAI,EAAS,EAAS,MAAA,CAAO,EAG9B,CACT,MAAgB,CACd,QAAQ,IAAI,sCAAsC,EAClD,MAAM,EAAS,MAAM,OAAO,MAAM,CAAO,EAEzC,OAAI,GAIG,IAAI,SAAS,UAAW,CAAE,OAAQ,IAAK,CAChD,CACF,CAKA,eAAe,EAAqB,EAAkB,EAAsC,CAC1F,MAAM,EAAS,MAAM,OAAO,MAAM,CAAO,EAEnC,EAAe,MAAM,CAAO,EAAE,KAAK,IACnC,EAAS,IACG,OAAO,KAAK,CAAS,EAC7B,QAAU,EAAE,IAAI,EAAS,EAAS,MAAA,CAAO,CAAC,EAE3C,EACR,EAAE,MAAM,IACH,GAGG,IAAI,SAAS,UAAW,CAAE,OAAQ,IAAK,CAC/C,EAED,OAAO,GAAU,CACnB,CAKA,KAAK,iBAAiB,QAAU,GAAU,CACxC,MAAM,EAAM,IAAI,IAAI,EAAM,QAAQ,GAAG,EAC/B,EAAW,EAAmB,CAAG,EAEnC,IAAa,gBAIjB,EAAM,aACH,SAAY,CACX,OAAQ,EAAA,CACN,IAAK,cACH,OAAO,EAAW,EAAM,QAAS,CAAY,EAE/C,IAAK,gBACH,OAAO,EAAa,EAAM,QAAS,CAAa,EAElD,IAAK,yBACH,OAAO,EAAqB,EAAM,QAAS,CAAa,EAE1D,QACE,OAAO,MAAM,EAAM,OAAO,CAAA,CAEhC,GAAA,CAAG,CAEP,CAAC,EAKD,KAAK,iBAAiB,OAAS,GAAU,CACvC,MAAM,EAAY,EACd,EAAU,MAAQ,iBACpB,EAAU,WACP,SAAY,CACX,QAAQ,IAAI,gCAAgC,EAE5C,GAAI,CACF,MAAM,EAAW,MAAM,EAAA,EAEvB,UAAW,KAAW,EACpB,GAAI,EAEgB,MAAM,QAAQ,WAC9B,EAAQ,UAAU,IAAI,GACpB,MAAM,EAAK,CACT,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAA,EAC3B,KAAM,KAAK,UAAU,CAAC,QAAS,EAAQ,KAAK,CAAC,CAAA,CAC9C,CAAA,CACH,GAI2B,KAAK,GAAK,EAAE,SAAW,WAAW,GAE7D,MAAM,EAAe,EAAQ,EAAE,CAEnC,OAAS,EAAO,CACd,QAAQ,MAAM,+BAAgC,CAAK,CACrD,EAIiB,MAAM,KAAK,QAAQ,SAAA,GAC3B,QAAS,GAAmB,CACrC,EAAO,YAAY,CACjB,KAAM,gBACN,MAAO,EAAS,MAAA,CACjB,CACH,CAAC,CACH,OAAS,EAAO,CACd,QAAQ,MAAM,+BAAgC,CAAK,CACrD,CACF,GAAA,CAAG,CAGT,CAAC,EAKD,KAAK,iBAAiB,UAAY,GAAU,CAC1C,KAAM,CAAE,KAAA,EAAM,QAAA,CAAA,EAAY,EAAM,KAEhC,OAAQ,EAAA,CACN,IAAK,gBACH,EAAa,CAAO,EAAE,KAAK,IAAM,CAC/B,EAAM,MAAM,CAAC,GAAG,YAAY,CAAE,QAAS,GAAM,CAC/C,CAAC,EAAE,MAAO,GAAiB,CACzB,EAAM,MAAM,CAAC,GAAG,YAAY,CAAE,QAAS,GAAO,MAAO,EAAM,QAAS,CACtE,CAAC,EACD,MAEF,IAAK,YACH,EAAA,EAAoB,KAAK,GAAY,CACnC,EAAM,MAAM,CAAC,GAAG,YAAY,CAAE,SAAA,EAAU,CAC1C,CAAC,EAAE,MAAO,GAAiB,CACzB,EAAM,MAAM,CAAC,GAAG,YAAY,CAAE,MAAO,EAAM,QAAS,CACtD,CAAC,EACD,MAEF,IAAK,cACH,EAAA,EAAa,KAAK,IAAM,CACtB,EAAM,MAAM,CAAC,GAAG,YAAY,CAAE,QAAS,GAAM,CAC/C,CAAC,EAAE,MAAO,GAAiB,CACzB,EAAM,MAAM,CAAC,GAAG,YAAY,CAAE,QAAS,GAAO,MAAO,EAAM,QAAS,CACtE,CAAC,EACD,MAEF,IAAK,eACH,KAAK,YAAA,EACL,KAAA,CAEN,CAAC,EAKD,KAAK,iBAAiB,OAAS,GAAU,CACvC,GAAI,CAAC,EAAM,KACT,OAGF,MAAM,EAAO,EAAM,KAAK,KAAA,EAExB,EAAM,UACJ,KAAK,aAAa,iBAAiB,EAAK,MAAO,CAC7C,KAAM,EAAK,KACX,KAAM,oBACN,MAAO,oBACP,IAAK,EAAK,KAAO,kBACjB,KAAM,EAAK,GAAA,CACZ,CAAA,CAEL,CAAC,EAKD,KAAK,iBAAiB,oBAAsB,GAAU,CACpD,EAAM,aAAa,MAAA,EAEnB,EAAM,UACJ,KAAK,QAAQ,SAAS,CAAE,KAAM,SAAU,EAAE,KAAK,GAAW,CACxD,MAAM,EAAM,EAAM,aAAa,MAAQ,IAGvC,UAAW,KAAU,EACnB,GAAI,EAAO,MAAQ,GAAO,UAAW,EACnC,OAAQ,EAAwB,MAAA,EAKpC,GAAI,KAAK,QAAQ,WACf,OAAO,KAAK,QAAQ,WAAW,CAAG,CAItC,CAAC,CAAA,CAEL,CAAC,EAED,QAAQ,IAAI,4BAA4B","file":"service-worker.js","sourcesContent":["/**\n * Fairfield Nostr PWA Service Worker\n * Implements caching strategies, offline support, and background sync\n */\n\n/// <reference lib=\"webworker\" />\n\ndeclare const self: ServiceWorkerGlobalScope;\n\n// Workbox manifest injection point - DO NOT REMOVE\nconst manifest = self.__WB_MANIFEST;\n\nconst CACHE_VERSION = 'v1';\nconst STATIC_CACHE = `fairfield-nostr-static-${CACHE_VERSION}`;\nconst DYNAMIC_CACHE = `fairfield-nostr-dynamic-${CACHE_VERSION}`;\nconst PROFILE_CACHE = `fairfield-nostr-profiles-${CACHE_VERSION}`;\n\n// Use manifest for precaching, or fallback to static list\nconst STATIC_ASSETS = manifest?.length > 0\n  ? manifest.map((entry: { url: string }) => entry.url)\n  : [\n      '/',\n      '/index.html',\n      '/manifest.json',\n      '/favicon.ico'\n    ];\n\nconst QUEUE_DB_NAME = 'fairfield-nostr-queue';\nconst QUEUE_STORE_NAME = 'outgoing-messages';\nconst QUEUE_DB_VERSION = 1;\n\ninterface QueuedMessage {\n  id: string;\n  timestamp: number;\n  event: NostrEventSW;\n  relayUrls: string[];\n}\n\ninterface NostrEventSW {\n  kind: number;\n  created_at: number;\n  tags: string[][];\n  content: string;\n  pubkey: string;\n  id?: string;\n  sig?: string;\n}\n\n/**\n * Initialize IndexedDB for message queue\n */\nasync function initQueueDB(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(QUEUE_DB_NAME, QUEUE_DB_VERSION);\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve(request.result);\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n\n      if (!db.objectStoreNames.contains(QUEUE_STORE_NAME)) {\n        const store = db.createObjectStore(QUEUE_STORE_NAME, { keyPath: 'id' });\n        store.createIndex('timestamp', 'timestamp', { unique: false });\n      }\n    };\n  });\n}\n\n/**\n * Add message to queue\n */\nasync function queueMessage(message: QueuedMessage): Promise<void> {\n  const db = await initQueueDB();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction([QUEUE_STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(QUEUE_STORE_NAME);\n    const request = store.add(message);\n\n    request.onsuccess = () => resolve();\n    request.onerror = () => reject(request.error);\n  });\n}\n\n/**\n * Get all queued messages\n */\nasync function getQueuedMessages(): Promise<QueuedMessage[]> {\n  const db = await initQueueDB();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction([QUEUE_STORE_NAME], 'readonly');\n    const store = transaction.objectStore(QUEUE_STORE_NAME);\n    const request = store.getAll();\n\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\n/**\n * Remove message from queue\n */\nasync function dequeueMessage(id: string): Promise<void> {\n  const db = await initQueueDB();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction([QUEUE_STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(QUEUE_STORE_NAME);\n    const request = store.delete(id);\n\n    request.onsuccess = () => resolve();\n    request.onerror = () => reject(request.error);\n  });\n}\n\n/**\n * Clear all queued messages\n */\nasync function clearQueue(): Promise<void> {\n  const db = await initQueueDB();\n\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction([QUEUE_STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(QUEUE_STORE_NAME);\n    const request = store.clear();\n\n    request.onsuccess = () => resolve();\n    request.onerror = () => reject(request.error);\n  });\n}\n\n/**\n * Install event - cache static assets\n */\nself.addEventListener('install', (event) => {\n  console.log('[SW] Installing service worker...');\n\n  event.waitUntil(\n    (async () => {\n      const cache = await caches.open(STATIC_CACHE);\n      await cache.addAll(STATIC_ASSETS);\n      await self.skipWaiting();\n    })()\n  );\n});\n\n/**\n * Activate event - clean up old caches\n */\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activating service worker...');\n\n  event.waitUntil(\n    (async () => {\n      const cacheNames = await caches.keys();\n      await Promise.all(\n        cacheNames\n          .filter(name =>\n            name.startsWith('fairfield-nostr-') &&\n            !name.includes(CACHE_VERSION)\n          )\n          .map(name => caches.delete(name))\n      );\n      await self.clients.claim();\n    })()\n  );\n});\n\n/**\n * Determine caching strategy based on request\n */\nfunction getCachingStrategy(url: URL): 'cache-first' | 'network-first' | 'stale-while-revalidate' | 'network-only' {\n  const pathname = url.pathname;\n\n  // Network only for WebSocket connections\n  if (url.protocol === 'wss:' || url.protocol === 'ws:') {\n    return 'network-only';\n  }\n\n  // Cache first for static assets\n  if (\n    pathname.endsWith('.js') ||\n    pathname.endsWith('.css') ||\n    pathname.endsWith('.html') ||\n    pathname.endsWith('.ico') ||\n    pathname.endsWith('.png') ||\n    pathname.endsWith('.jpg') ||\n    pathname.endsWith('.svg') ||\n    pathname.endsWith('.woff2') ||\n    pathname.endsWith('.woff') ||\n    pathname.endsWith('.ttf')\n  ) {\n    return 'cache-first';\n  }\n\n  // Stale while revalidate for profiles and avatars\n  if (\n    pathname.includes('/avatar') ||\n    pathname.includes('/profile') ||\n    pathname.includes('/metadata')\n  ) {\n    return 'stale-while-revalidate';\n  }\n\n  // Network first for API calls and dynamic content\n  return 'network-first';\n}\n\n/**\n * Cache-first strategy with network fallback\n */\nasync function cacheFirst(request: Request, cacheName: string): Promise<Response> {\n  const cached = await caches.match(request);\n\n  if (cached) {\n    return cached;\n  }\n\n  try {\n    const response = await fetch(request);\n\n    if (response.ok) {\n      const cache = await caches.open(cacheName);\n      cache.put(request, response.clone());\n    }\n\n    return response;\n  } catch (error) {\n    console.error('[SW] Cache-first fetch failed:', error);\n    return new Response('Offline', { status: 503 });\n  }\n}\n\n/**\n * Network-first strategy with cache fallback\n */\nasync function networkFirst(request: Request, cacheName: string): Promise<Response> {\n  try {\n    const response = await fetch(request);\n\n    if (response.ok) {\n      const cache = await caches.open(cacheName);\n      cache.put(request, response.clone());\n    }\n\n    return response;\n  } catch (error) {\n    console.log('[SW] Network failed, trying cache...');\n    const cached = await caches.match(request);\n\n    if (cached) {\n      return cached;\n    }\n\n    return new Response('Offline', { status: 503 });\n  }\n}\n\n/**\n * Stale-while-revalidate strategy\n */\nasync function staleWhileRevalidate(request: Request, cacheName: string): Promise<Response> {\n  const cached = await caches.match(request);\n\n  const fetchPromise = fetch(request).then(response => {\n    if (response.ok) {\n      const cache = caches.open(cacheName);\n      cache.then(c => c.put(request, response.clone()));\n    }\n    return response;\n  }).catch(() => {\n    if (cached) {\n      return cached;\n    }\n    return new Response('Offline', { status: 503 });\n  });\n\n  return cached || fetchPromise;\n}\n\n/**\n * Fetch event - implement caching strategies\n */\nself.addEventListener('fetch', (event) => {\n  const url = new URL(event.request.url);\n  const strategy = getCachingStrategy(url);\n\n  if (strategy === 'network-only') {\n    return;\n  }\n\n  event.respondWith(\n    (async () => {\n      switch (strategy) {\n        case 'cache-first':\n          return cacheFirst(event.request, STATIC_CACHE);\n\n        case 'network-first':\n          return networkFirst(event.request, DYNAMIC_CACHE);\n\n        case 'stale-while-revalidate':\n          return staleWhileRevalidate(event.request, PROFILE_CACHE);\n\n        default:\n          return fetch(event.request);\n      }\n    })()\n  );\n});\n\n/**\n * Background sync event - process queued messages\n */\nself.addEventListener('sync', (event) => {\n  const syncEvent = event as ExtendableEvent & { tag: string };\n  if (syncEvent.tag === 'sync-messages') {\n    syncEvent.waitUntil(\n      (async () => {\n        console.log('[SW] Background sync triggered');\n\n        try {\n          const messages = await getQueuedMessages();\n\n          for (const message of messages) {\n            try {\n              // Send message to all specified relays\n              const responses = await Promise.allSettled(\n                message.relayUrls.map(url =>\n                  fetch(url, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify(['EVENT', message.event])\n                  })\n                )\n              );\n\n              // Remove from queue if at least one relay succeeded\n              const hasSuccess = responses.some(r => r.status === 'fulfilled');\n              if (hasSuccess) {\n                await dequeueMessage(message.id);\n              }\n            } catch (error) {\n              console.error('[SW] Failed to sync message:', error);\n            }\n          }\n\n          // Notify clients about sync completion\n          const allClients = await self.clients.matchAll();\n          allClients.forEach((client: Client) => {\n            client.postMessage({\n              type: 'SYNC_COMPLETE',\n              count: messages.length\n            });\n          });\n        } catch (error) {\n          console.error('[SW] Background sync failed:', error);\n        }\n      })()\n    );\n  }\n});\n\n/**\n * Message event - handle commands from main thread\n */\nself.addEventListener('message', (event) => {\n  const { type, payload } = event.data;\n\n  switch (type) {\n    case 'QUEUE_MESSAGE':\n      queueMessage(payload).then(() => {\n        event.ports[0]?.postMessage({ success: true });\n      }).catch((error: Error) => {\n        event.ports[0]?.postMessage({ success: false, error: error.message });\n      });\n      break;\n\n    case 'GET_QUEUE':\n      getQueuedMessages().then(messages => {\n        event.ports[0]?.postMessage({ messages });\n      }).catch((error: Error) => {\n        event.ports[0]?.postMessage({ error: error.message });\n      });\n      break;\n\n    case 'CLEAR_QUEUE':\n      clearQueue().then(() => {\n        event.ports[0]?.postMessage({ success: true });\n      }).catch((error: Error) => {\n        event.ports[0]?.postMessage({ success: false, error: error.message });\n      });\n      break;\n\n    case 'SKIP_WAITING':\n      self.skipWaiting();\n      break;\n  }\n});\n\n/**\n * Push notification event\n */\nself.addEventListener('push', (event) => {\n  if (!event.data) {\n    return;\n  }\n\n  const data = event.data.json();\n\n  event.waitUntil(\n    self.registration.showNotification(data.title, {\n      body: data.body,\n      icon: '/icon-192x192.png',\n      badge: '/icon-192x192.png',\n      tag: data.tag || 'fairfield-nostr',\n      data: data.url\n    })\n  );\n});\n\n/**\n * Notification click event\n */\nself.addEventListener('notificationclick', (event) => {\n  event.notification.close();\n\n  event.waitUntil(\n    self.clients.matchAll({ type: 'window' }).then(clients => {\n      const url = event.notification.data || '/';\n\n      // Check if there's already a window open\n      for (const client of clients) {\n        if (client.url === url && 'focus' in client) {\n          return (client as WindowClient).focus();\n        }\n      }\n\n      // Open a new window\n      if (self.clients.openWindow) {\n        return self.clients.openWindow(url);\n      }\n\n      return undefined;\n    })\n  );\n});\n\nconsole.log('[SW] Service worker loaded');\n\nexport {};\n"]}